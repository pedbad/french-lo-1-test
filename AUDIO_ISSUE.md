# AUDIO_ISSUE.md

## Audio Path Normalization Issue (NFC vs NFD)

### Your problem

Some audio paths can fail because of Unicode normalization mismatch between:

- filenames stored on disk, and
- filenames generated by code at runtime.

If a file on disk is NFC (composed) but code resolves the path in NFD (decomposed), the URL can point to a different byte sequence and fail with `404`.

Example:

```js
// File on disk (NFC)
"café.mp3" // é = U+00E9

// Runtime path (NFD)
"café.mp3" // e + combining acute = U+0065 + U+0301

// Visually similar, but different encoding -> possible mismatch / 404
```

### Why this matters here

LO audio uses many accented filenames (for example `Salut, ça va.mp3`, `Très bien, merci !.mp3`), so normalization must be consistent across:

- JSON references in `src/learningObjectConfigurations/fr/*.json`
- runtime URL construction (`resolveAsset()`)
- actual files in `public/sounds/fr`

### Fix strategy

1. Keep runtime URL handling deterministic in `resolveAsset()` (no destructive normalization transforms).
2. Normalize filenames on disk to a single canonical form (recommended: **NFC**).
3. Ensure JSON references match the normalized filenames exactly.

### Recommendation

Use **one encoding standard everywhere**, and normalize filenames on disk so future imports/renames do not reintroduce mixed Unicode forms.

If you intentionally normalize in code, use the same form as disk filenames (for example NFC):

```js
path.normalize("NFC")
```

### Practical policy for this repo

- Canonical on disk: **NFC**
- JSON filenames: exact match to on-disk names
- Runtime path builder: safe URL join + URI encoding, without changing logical filename spelling

